---
name: 'Knowledge Graph MCP Tools'
description: 'Reference for the Knowledge Graph MCP server tools used for codebase navigation, structural queries, dependency analysis, impact analysis, source code reading, change recipes, compound cross-layer queries, and framework statistics.'
---

# Knowledge Graph MCP Tools — Complete Reference

The **knowledge-graph** MCP server provides structural queries over any Python
codebase parsed by `generate_graph_v2.py`. Use these tools instead of manually
exploring files to navigate the codebase efficiently.

> **Architecture**: The graph uses hash-based node IDs (12-char SHA256),
> bidirectional edges, and is stored in a YAML file. At server startup
> (or on first tool call), the YAML is loaded into a **NetworkX DiGraph** in
> memory. All tool queries run against this in-memory graph — no YAML parsing
> at query time. The YAML is generated by `generate_graph_v2.py`.

**Always start with `get_architecture` or `search_nodes` to orient, then drill
down with specific queries.**

---

## Tool Reference

### Core Navigation Tools

| Tool | When to Use | Example |
|---|---|---|
| `get_architecture` | **Start here** — get top-level package tree overview | `get_architecture()` |
| `search_nodes` | Find classes/fixtures/files by name pattern | `search_nodes("auth.*handler", "class")` |
| `query_node` | Get full details + edges of a specific node | `query_node("MyClass")` |
| `get_domain_subgraph` | See all files/classes/fixtures matching a domain keyword | `get_domain_subgraph("auth")` |
| `get_fixture_chain` | Trace the full fixture dependency chain | `get_fixture_chain("db_session")` |
| `find_impact` | BFS — "what breaks if I change X?" | `find_impact("UserService", depth=3)` |
| `find_dependencies` | DFS — "what does X depend on?" | `find_dependencies("UserService")` |
| `find_path` | Shortest path between two nodes | `find_path("Controller", "Database")` |
| `get_change_recipe` | Step-by-step guide for specific change types | `get_change_recipe("add_module")` |
| `get_graph_stats` | Codebase-wide statistics | `get_graph_stats()` |
| `get_source_snippet` | **Read source code** for any graph node | `get_source_snippet("MyClass", 30)` |
| `get_clarification_checklist` | **Decision gate** — what to ask before starting | `get_clarification_checklist("debug_fix")` |
| `validate_task_context` | **Check readiness** — is enough context gathered? | `validate_task_context("code_change", {...})` |

### Compound Query Tools

These tools combine multiple graph operations into a single call, reducing
context window usage and round-trips. **Prefer these over chaining individual
tools when the compound tool matches your need.**

| Tool | When to Use | Example |
|---|---|---|
| `get_cross_layer_trace` | **Trace a full connection path** between two nodes with enriched per-hop details and optional source snippets | `get_cross_layer_trace("handler", "database")` |
| `get_change_context` | **One-call change planning** — combines dependencies, impact, fixture chain, related tests, lifecycle methods, and recipe hints | `get_change_context("UserService", "bug_fix")` |
| `get_layer_interfaces` | **Find all connections between two layers** — groups edges by type (inherits, calls, imports, etc.) | `get_layer_interfaces("api", "models")` |

---

## Common Workflows Using Graph Tools

### Understanding a Component
```
# Quick (1 call) — use compound tool:
get_change_context("ComponentClass", "bug_fix")
    → Returns dependencies, impact, fixture chain, tests, lifecycle — all at once

# Manual drill-down if needed:
1. search_nodes("component_name")      → Find the node
2. query_node("ComponentClass")        → Get edges and details
3. find_dependencies("ComponentClass") → What does it depend on?
4. find_impact("ComponentClass")       → What depends on it?
```

### Preparing for a Code Change
```
# Recommended (1-2 calls):
1. get_change_context("target", "refactor")  → Full context in one call
2. get_source_snippet("Class", 50)           → Read the actual code

# Manual drill-down if needed:
1. get_change_recipe("change_type")   → Step-by-step instructions
2. get_domain_subgraph("domain")      → All files in the domain
3. find_impact("target_component")    → Blast radius
4. get_source_snippet("Class", 50)    → Read the actual code
```

### Tracing Execution Paths (Cross-Layer)
```
# Recommended (1 call):
get_cross_layer_trace("handler", "database")
    → Returns enriched path: fixture scope, class bases, lifecycle tags per hop

# With source code included:
get_cross_layer_trace("handler", "database", include_source=True)
```

### Understanding Layer Boundaries
```
get_layer_interfaces("api", "models")
    → All connections between API layer and models layer, grouped by edge type
    → Shows inherits, calls, imports, has_subclass relationships
```
